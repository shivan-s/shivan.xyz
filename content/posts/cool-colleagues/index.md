---
author: Shivan Sivakumaran
title: Summing up 2025
date: 2025-12-05
summary: Wrapping up the year that has been
category: ["Programming", "Life"]
tags: ["Gratitude"]
draft: false
cover:
  image: image.jpg
  alt: alt text
  caption: caption
  relative: false
  hidden: true
---

There is still lots left on the table that I wish I had accomplished this year:

1. I wish I made more personal projects that weren't just web projects
2. I wish I wrote more blog posts and created more content
3. I wish I studyied and read more

Naturally, you make big goals, never achieve them, and you find yourself acceptng that you will always be disappointed.

However, I forget what I _did_ achieve or how I've evolved in my career. And that's what I want to share with you in this post.

## But, First

Let's just start with some gratitude I have for a colleague.

To get a better understanding of why I am so grateful, let me set the scene.

Imagine that sinking feeling you get in your stomach. A bug you wrote into production.

Before you can process the guilt, you are frantically coming up with a fix.

Heart beating for an extended period of time, you finally come up with a fix. You acknowledge the team of the problem and as you are about to sign off, your colleague says this:

> God gives his toughest battles to his strongest soldiers

Such kind and uplifting words. And for that small, cherrishable moment, those uncomfortable emotions that you subside.

So, thank you to that colleague.

On that note, I think a good resource for homework is:

- [_Postmortem Culture: Learning from Failure_](https://sre.google/sre-book/postmortem-culture/).

## Smaller PRs and Product Thinking

These two books having changed how I conduct pull requests.

- _Accelerate_ by [Nicole Forsgren, PhD](https://nicolefv.com/), Jez Humble and Gene Kim.
- [_The Phoenix Project_](https://itrevolution.com/product/the-phoenix-project/) by Gene Kim, Kevin Behr, and George Spafford

I make the effort to split my PRs into smaller chunks, often splitting refactors from codes directly related to the feature.

In my understanding, this should make the code easier to review. It also makes small bugs easier to identify if they do end up in production (plus you also have the ability role back small changes easier).

Also, when you adopt the focus of smaller PRs, you start to break problems down into smaller items, which can be discussed amongst the team. If you start going down the wrong track, for example, then it's easier to make a course correction. Compare this to committing to the wrong direction for days or even weeks only find out you need to go up the stream again because you slightly misunderstood the requirements.

Another benefit is that with the code changes being small you can focus on the quality of code rather than "yolo" merging because you saw good screenshots and testing implementation.

Thanks to this way of going PRs, I've been thinking about how my code impacts the business rather than writing code for code's sake.

How useful is this feature? Is the way I'm implementing this feature going to do well for the business? If I write the feature this way, will be easy to maintain, change, extends or even get rid of if we find it no longer being useful?

And here we have the shift into becoming more product focused - which I think is big challenge that I'm trying to get better at - are we even building what the user wants?

## Programming is Art and it's a Craft

I'm impressed with the Barista. Detail is required with making a coffee: the dosing, the grind size, the tamper of the plaque, and with every coffee - how do I make it better than the last?

Or how about the Pilot? Every landing is better. Drill emergencies and practicing skills that had already been learnt because this requires constant upkeep - if you don't use it you lose it.

Both professions are constantly reflecting and trying to improve their respective craft.

My entry into this career has been a blessing. In realising my luck, I've made the effort to treat programming more like a craft than a regular job. A craft that needs constant improvement, learning, and curiosity.

Speaking of curiosity, please watch this talk by [Dr Werner Vogels about the _Renaissance Developer_ and staying curious](https://www.allthingsdistributed.com/2025/11/tech-predictions-for-2026-and-beyond).

{{<youtube 3Y1G9najGiI>}}

I've supplemented by top-down learning approach (one where I had no idea how the lower level implementation work such as memory management in C) with going deep.

My attempts are to:

- plough through the [wizard book](https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs)
- [learn C++](https://github.com/shivan-s/learn-cpp).
- try a new language a year for [Advent of Code](https://adventofcode.com/) - [this year I did Elixir](https://github.com/shivan-s/aoc/tree/main/2025)
- maybe a framework too? I might give [Phoenix](https://www.phoenixframework.org/) a try?
- make more content, be wrong and get corrected

## Conclusion

I have improved in 2025. I have cool colleauges. I write small PRs, and I have adopted a mindset or treating programming like a craft to continually get better.

Not only this, it's important to remain grounded. Don't forget the basics - do you job in a timely matter with minimum fuss, have some balance and take rest, be nice to everyone (or most people).

I'm excited to see where 2026 takes us! Thanks for reading.
